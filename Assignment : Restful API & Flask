1', 'What is a RESTful API?')
pdf.answer("""RESTful API (Representational State Transfer) is an architectural style for designing networked applications. It uses HTTP requests to perform CRUD operations on resources.

Key Principles:
• Stateless: Each request contains all necessary information
• Client-Server: Separation of concerns
• Uniform Interface: Standardized way to interact with resources
• Cacheable: Responses can be cached
• Layered System: Multiple layers between client and server
• Code on Demand (optional): Server can send executable code

Characteristics:
• Resources identified by URLs
• Uses standard HTTP methods
• Resources can have multiple representations (JSON, XML)
• Stateless communication
• Clear separation between client and server

Example RESTful endpoints:
GET    /api/users     - Get all users
GET    /api/users/1   - Get user with ID 1
POST   /api/users     - Create new user
PUT    /api/users/1   - Update user with ID 1
DELETE /api/users/1   - Delete user with ID 1

Benefits:
• Scalability
• Flexibility
• Independence (client and server can be built separately)
• Easy to understand and implement""")
pdf.ln(5)

# Question 2
pdf.question('2', 'What is Flask, and why is it popular for building APIs?')
pdf.answer("""Flask is a lightweight and flexible micro web framework for Python. It's designed to make getting started quick and easy, with the ability to scale up to complex applications.

Why Flask is popular for building APIs:

1. Lightweight and Minimal:
   • Simple and easy to learn
   • No unnecessary dependencies
   • Clean and elegant code structure

2. Flexibility:
   • No strict project structure requirements
   • Choose your own tools and libraries
   • Easy to customize and extend

3. Built-in Development Server:
   • Quick testing and debugging
   • Automatic reloading during development
   • Easy to get started

4. RESTful Request Handling:
   • Built-in support for HTTP methods
   • Easy route definition with decorators
   • Request and response objects

5. Extensive Documentation:
   • Well-documented with many examples
   • Large community support
   • Plenty of tutorials and resources

6. Extensions Ecosystem:
   • Flask-SQLAlchemy for databases
   • Flask-RESTful for API development
   • Flask-JWT for authentication
   • Flask-Migrate for database migrations

7. JSON Support:
   • Built-in JSON handling
   • Easy to return JSON responses
   • Automatic JSON parsing

Example:
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/hello')
def hello():
    return jsonify({'message': 'Hello World'})

if __name__ == '__main__':
    app.run(debug=True)""")
pdf.ln(5)

# Question 3
pdf.question('3', 'What are HTTP methods used in RESTful APIs?')
pdf.answer("""HTTP methods (also called HTTP verbs) indicate the desired action to be performed on a resource in RESTful APIs.

Main HTTP Methods:

1. GET
   • Purpose: Retrieve data from the server
   • Idempotent: Yes (multiple identical requests have same effect)
   • Safe: Yes (doesn't modify data)
   • Body: Not typically used
   • Example: GET /api/users/123

2. POST
   • Purpose: Create new resources or submit data
   • Idempotent: No (multiple requests create multiple resources)
   • Safe: No
   • Body: Contains new resource data
   • Example: POST /api/users with user data

3. PUT
   • Purpose: Update or replace an existing resource
   • Idempotent: Yes
   • Safe: No
   • Body: Contains complete updated resource
   • Example: PUT /api/users/123 with updated user data

4. PATCH
   • Purpose: Partially update a resource
   • Idempotent: No (depends on implementation)
   • Safe: No
   • Body: Contains partial updates
   • Example: PATCH /api/users/123 with only email update

5. DELETE
   • Purpose: Remove a resource
   • Idempotent: Yes
   • Safe: No
   • Body: Not typically used
   • Example: DELETE /api/users/123

6. Additional Methods:
   • HEAD: Same as GET but returns only headers
   • OPTIONS: Returns allowed HTTP methods for a resource
   • CONNECT: Establishes a tunnel to the server
   • TRACE: Echoes the received request for testing

HTTP Status Codes:
• 200 OK: Successful GET, PUT, PATCH, DELETE
• 201 Created: Successful POST
• 204 No Content: Successful DELETE (no response body)
• 400 Bad Request: Invalid request
• 401 Unauthorized: Authentication required
• 403 Forbidden: Authenticated but not authorized
• 404 Not Found: Resource doesn't exist
• 500 Internal Server Error: Server-side error""")
pdf.ln(5)

# Question 4
pdf.question('4', 'What is the purpose of the @app.route() decorator in Flask?')
pdf.answer("""The @app.route() decorator in Flask is used to bind a URL to a function. It defines which URLs trigger which functions in your Flask application.

Purpose and Functionality:

1. URL Routing:
   • Maps URLs to Python functions
   • Determines what code executes for specific URLs
   • Creates the routing table for the application

2. HTTP Method Binding:
   • Specifies which HTTP methods are allowed
   • Can restrict routes to specific methods

3. Dynamic URL Building:
   • Captures variable parts of URLs
   • Passes captured values to functions

Basic Syntax:
@app.route('/url/path', methods=['GET', 'POST'])
def function_name():
    # Function body
    return response

Examples:

# 1. Simple route
@app.route('/')
def home():
    return 'Welcome to Home Page'

# 2. Route with specific methods
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        return 'Processing login'
    return 'Show login form'

# 3. Dynamic route with variable
@app.route('/user/<username>')
def show_user(username):
    return f'User: {username}'

# 4. Route with type converter
@app.route('/post/<int:post_id>')
def show_post(post_id):
    return f'Post ID: {post_id}'

# 5. Multiple URLs for same function
@app.route('/about')
@app.route('/about/')
def about():
    return 'About Page'

# 6. Route with defaults
@app.route('/profile/', defaults={'username': 'anonymous'})
@app.route('/profile/<username>')
def profile(username):
    return f'Profile: {username}'

Type Converters Available:
• string: (default) accepts any text without slashes
• int: accepts positive integers
• float: accepts positive floating point values
• path: like string but accepts slashes
• uuid: accepts UUID strings

Benefits:
• Clean and readable URL definitions
• Easy to maintain and modify routes
• Automatic URL generation with url_for()
• Flexible parameter handling""")
pdf.ln(5)

# Question 5
pdf.question('5', 'What is the role of Flask-SQLAlchemy?')
pdf.answer("""Flask-SQLAlchemy is an extension for Flask that adds support for SQLAlchemy, a powerful SQL toolkit and Object-Relational Mapping (ORM) library for Python.

Role and Purpose:

1. Database Integration:
   • Simplifies database connections
   • Provides a high-level ORM interface
   • Supports multiple database backends

2. Object-Relational Mapping (ORM):
   • Maps Python classes to database tables
   • Converts Python objects to database records
   • Eliminates need to write raw SQL

3. Session Management:
   • Handles database sessions automatically
   • Manages transactions
   • Provides thread-safe sessions

4. Model Definition:
   • Define database models as Python classes
   • Specify relationships between tables
   • Set constraints and data types

Key Features:

1. Model Definition:
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy(app)

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    posts = db.relationship('Post', backref='author', lazy=True)

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'))

2. Database Operations:
# Create tables
db.create_all()

# Create record
user = User(username='john', email='john@example.com')
db.session.add(user)
db.session.commit()

# Query records
users = User.query.all()
user = User.query.filter_by(username='john').first()
johns_posts = Post.query.filter_by(author=user).all()

# Update
user.email = 'newemail@example.com'
db.session.commit()

# Delete
db.session.delete(user)
db.session.commit()

3. Relationship Types:
   • One-to-Many (as shown above)
   • Many-to-One (inverse of One-to-Many)
   • Many-to-Many (using association tables)
   • One-to-One (using uselist=False)

4. Configuration:
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///mydatabase.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

Advantages:
• Write Python code instead of SQL
• Database agnostic (switch databases easily)
• Protection against SQL injection
• Automatic escaping of parameters
• Lazy loading and eager loading options
• Migration support with Flask-Migrate""")
pdf.ln(5)

# Question 6
pdf.question('6', 'How do you create a basic Flask application?')
pdf.answer("""Creating a basic Flask application involves several steps. Here's a complete guide with examples:

Step 1: Install Flask
pip install flask

Step 2: Create Basic Application Structure

# app.py - Minimal Flask App
from flask import Flask

# Create Flask application instance
app = Flask(__name__)

# Define routes
@app.route('/')
def home():
    return 'Hello, World!'

@app.route('/about')
def about():
    return 'About Page'

# Run the application
if __name__ == '__main__':
    app.run(debug=True)

Step 3: Run the Application
python app.py
# Access at http://127.0.0.1:5000

More Complete Example with Templates and Static Files:

Project Structure:
my_flask_app/
├── app.py
├── requirements.txt
├── static/
│   ├── css/
│   │   └── style.css
│   └── js/
│       └── script.js
└── templates/
    ├── base.html
    ├── index.html
    └── about.html

# app.py - Complete Example
from flask import Flask, render_template, request, jsonify
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-here'
app.config['DEBUG'] = True

# Home route
@app.route('/')
def index():
    return render_template('index.html', title='Home')

# About route
@app.route('/about')
def about():
    return render_template('about.html', title='About')

# Route with variable
@app.route('/user/<username>')
def user_profile(username):
    return render_template('profile.html', username=username)

# API route returning JSON
@app.route('/api/data')
def get_data():
    data = {
        'users': [
            {'id': 1, 'name': 'John'},
            {'id': 2, 'name': 'Jane'}
        ]
    }
    return jsonify(data)

# Route handling both GET and POST
@app.route('/contact', methods=['GET', 'POST'])
def contact():
    if request.method == 'POST':
        name = request.form.get('name')
        email = request.form.get('email')
        # Process form data
        return f'Thank you {name}! We\'ll contact you at {email}'
    return render_template('contact.html')

# Error handlers
@app.errorhandler(404)
def page_not_found(error):
    return render_template('404.html'), 404

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

# requirements.txt
Flask==2.3.0
python-dotenv==1.0.0

<!-- templates/base.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{ title }} - My Flask App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <nav>
        <a href="{{ url_for('index') }}">Home</a>
        <a href="{{ url_for('about') }}">About</a>
        <a href="{{ url_for('contact') }}">Contact</a>
    </nav>
    
    <main>
        {% block content %}{% endblock %}
    </main>
    
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>

<!-- templates/index.html -->
{% extends "base.html" %}

{% block content %}
<h1>Welcome to My Flask App</h1>
<p>This is a basic Flask application with templates and static files.</p>
{% endblock %}

Key Configuration Options:
• debug=True: Enables debug mode with auto-reload
• host='0.0.0.0': Makes server accessible on network
• port=5000: Specifies port number
• secret_key: For sessions and security features

Running with Environment Variables:
# .env file
FLASK_APP=app.py
FLASK_ENV=development
FLASK_DEBUG=1

# Run with:
flask run""")
pdf.ln(5)

# Question 7
pdf.question('7', 'How do you return JSON responses in Flask?')
pdf.answer("""Flask provides multiple ways to return JSON responses. Here are the main methods with examples:

Method 1: Using jsonify() (Recommended)
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/user')
def get_user():
    user = {
        'id': 1,
        'name': 'John Doe',
        'email': 'john@example.com',
        'roles': ['admin', 'user']
    }
    return jsonify(user)

Method 2: Using make_response with jsonify
from flask import make_response, jsonify

@app.route('/api/product/<int:product_id>')
def get_product(product_id):
    product = {
        'id': product_id,
        'name': 'Laptop',
        'price': 999.99
    }
    response = make_response(jsonify(product))
    response.status_code = 200
    response.headers['X-Custom-Header'] = 'Custom Value'
    return response

Method 3: Returning dict directly (Flask 1.1+)
@app.route('/api/config')
def get_config():
    return {
        'version': '1.0.0',
        'environment': 'production',
        'features': ['auth', 'api', 'admin']
    }

Method 4: JSON with custom status code
@app.route('/api/user/create', methods=['POST'])
def create_user():
    # Process user creation
    return jsonify({
        'status': 'success',
        'message': 'User created successfully',
        'user_id': 123
    }), 201  # Created status code

Method 5: Returning lists
@app.route('/api/users')
def get_users():
    users = [
        {'id': 1, 'name': 'Alice'},
        {'id': 2, 'name': 'Bob'},
        {'id': 3, 'name': 'Charlie'}
    ]
    return jsonify(users)

Method 6: With custom headers
@app.route('/api/data')
def get_data():
    data = {'key': 'value'}
    response = jsonify(data)
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('X-Total-Count', '100')
    return response

Method 7: Error responses
@app.route('/api/user/<int:user_id>')
def get_user_by_id(user_id):
    user = find_user(user_id)
    if user is None:
        return jsonify({
            'error': 'User not found',
            'code': 404
        }), 404
    return jsonify(user)

Method 8: Complex nested structures
@app.route('/api/dashboard')
def get_dashboard():
    dashboard_data = {
        'user': {
            'name': 'John',
            'preferences': {
                'theme': 'dark',
                'notifications': True
            }
        },
        'stats': {
            'visits': 1234,
            'page_views': 5678
        },
        'recent_activity': [
            {'action': 'login', 'timestamp': '2024-01-01'},
            {'action': 'purchase', 'timestamp': '2024-01-02'}
        ]
    }
    return jsonify(dashboard_data)

Method 9: JSON with datetime objects
from datetime import datetime

def custom_json_encoder(obj):
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError(f'Object of type {obj.__class__.__name__} is not JSON serializable')

@app.route('/api/events')
def get_events():
    events = [
        {'name': 'Event 1', 'date': datetime.now()},
        {'name': 'Event 2', 'date': datetime(2024, 1, 1)}
    ]
    return jsonify(events)

Method 10: Using Flask-RESTful extension
from flask_restful import Api, Resource

api = Api(app)

class UserResource(Resource):
    def get(self, user_id):
        user = {'id': user_id, 'name': 'John'}
        return user  # Automatically JSON-encoded
    
    def post(self):
        # Create user
        return {'status': 'created'}, 201

api.add_resource(UserResource, '/api/user/<int:user_id>')

JSON Response Best Practices:
• Always use consistent response structure
• Include status codes appropriately
• Handle errors gracefully
• Use camelCase for JSON keys (or be consistent)
• Validate JSON before sending
• Set proper Content-Type header

Testing JSON Endpoints:
import requests
import json

# Test GET endpoint
response = requests.get('http://localhost:5000/api/user')
data = response.json()
print(data['name'])

# Test POST endpoint
headers = {'Content-Type': 'application/json'}
payload = {'name': 'New User', 'email': 'new@example.com'}
response = requests.post('http://localhost:5000/api/user/create', 
                         json=payload, headers=headers)""")
pdf.ln(5)

# Question 8
pdf.question('8', 'How do you handle POST requests in Flask?')
pdf.answer("""Handling POST requests in Flask involves receiving data from clients, processing it, and returning appropriate responses.

Basic POST Request Handling:

from flask import Flask, request, jsonify

app = Flask(__name__)

# 1. Basic POST route
@app.route('/api/data', methods=['POST'])
def handle_post():
    # Get JSON data
    data = request.get_json()
    return jsonify({'received': data, 'status': 'success'}), 201

# 2. POST with form data
@app.route('/submit-form', methods=['POST'])
def handle_form():
    name = request.form.get('name')
    email = request.form.get('email')
    age = request.form.get('age', type=int)
    
    return jsonify({
        'name': name,
        'email': email,
        'age': age
    })

# 3. POST with file upload
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'Empty filename'}), 400
    
    # Save file
    file.save(f'uploads/{file.filename}')
    return jsonify({'message': 'File uploaded successfully'})

# 4. POST with URL parameters
@app.route('/api/users/<int:user_id>/posts', methods=['POST'])
def create_post(user_id):
    data = request.get_json()
    post = {
        'user_id': user_id,
        'title': data.get('title'),
        'content': data.get('content')
    }
    # Save to database...
    return jsonify(post), 201

# 5. POST with validation
@app.route('/api/register', methods=['POST'])
def register():
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['username', 'email', 'password']
    for field in required_fields:
        if field not in data:
            return jsonify({'error': f'{field} is required'}), 400
    
    # Validate data types
    if not isinstance(data.get('username'), str):
        return jsonify({'error': 'Username must be string'}), 400
    
    # Validate email format
    if '@' not in data.get('email', ''):
        return jsonify({'error': 'Invalid email format'}), 400
    
    # Validate password length
    if len(data.get('password', '')) < 6:
        return jsonify({'error': 'Password too short'}), 400
    
    # Process registration
    return jsonify({'message': 'Registration successful'}), 201

# 6. POST with authentication
from functools import wraps

def require_api_key(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        if api_key and api_key == 'secret-key-123':
            return f(*args, **kwargs)
        return jsonify({'error': 'Invalid API key'}), 401
    return decorated

@app.route('/api/protected', methods=['POST'])
@require_api_key
def protected_post():
    data = request.get_json()
    return jsonify({'message': 'Access granted', 'data': data})

# 7. POST with different content types
@app.route('/api/multi-format', methods=['POST'])
def handle_multi_format():
    content_type = request.headers.get('Content-Type', '')
    
    if 'application/json' in content_type:
        data = request.get_json()
        return jsonify({'format': 'JSON', 'data': data})
    
    elif 'application/x-www-form-urlencoded' in content_type:
        data = request.form.to_dict()
        return jsonify({'format': 'Form', 'data': data})
    
    elif 'multipart/form-data' in content_type:
        data = request.form.to_dict()
        files = {k: v.filename for k, v in request.files.items()}
        return jsonify({'format': 'Multipart', 'data': data, 'files': files})
    
    else:
        return jsonify({'error': 'Unsupported content type'}), 415

# 8. POST with database integration
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
    email = db.Column(db.String(120))

@app.route('/api/users', methods=['POST'])
def create_user():
    data = request.get_json()
    
    # Check if user exists
    existing = User.query.filter_by(username=data.get('username')).first()
    if existing:
        return jsonify({'error': 'Username already exists'}), 409
    
    # Create new user
    user = User(
        username=data.get('username'),
        email=data.get('email')
    )
    db.session.add(user)
    db.session.commit()
    
    return jsonify({
        'id': user.id,
        'username': user.username,
        'email': user.email
    }), 201

# 9. POST with background tasks
import threading
import time

def long_task(data):
    time.sleep(10)  # Simulate long processing
    print(f"Processed: {data}")

@app.route('/api/async-task', methods=['POST'])
def async_task():
    data = request.get_json()
    thread = threading.Thread(target=long_task, args=(data,))
    thread.start()
    return jsonify({'message': 'Task started'}), 202

# 10. Complete CRUD example
@app.route('/api/items', methods=['POST'])
def create_item():
    """Create a new item"""
    data = request.get_json()
    
    # Validate
    if not data or 'name' not in data:
        return jsonify({'error': 'Name is required'}), 400
    
    # Create item (in real app, save to database)
    item = {
        'id': len(items) + 1,
        'name': data['name'],
        'description': data.get('description', ''),
        'created_at': datetime.now().isoformat()
    }
    items.append(item)
    
    return jsonify(item), 201

# Testing POST requests
import requests

# Test JSON POST
response = requests.post(
    'http://localhost:5000/api/users',
    json={'username': 'john', 'email': 'john@example.com'},
    headers={'X-API-Key': 'secret-key-123'}
)

# Test form POST
response = requests.post(
    'http://localhost:5000/submit-form',
    data={'name': 'John', 'email': 'john@example.com'}
)

# Test file upload
files = {'file': open('document.pdf', 'rb')}
response = requests.post('http://localhost:5000/upload', files=files)""")
pdf.ln(5)

# Question 9
pdf.question('9', 'How do you handle errors in Flask (e.g., 404)?')
pdf.answer("""Flask provides several ways to handle errors gracefully. Here's a comprehensive guide:

1. Basic Error Handlers using @app.errorhandler()

from flask import Flask, render_template, jsonify, abort
from werkzeug.exceptions import HTTPException

app = Flask(__name__)

# Handle 404 errors
@app.errorhandler(404)
def not_found_error(error):
    return render_template('404.html'), 404

# Handle 500 errors
@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()  # Rollback database if needed
    return render_template('500.html'), 500

2. JSON API Error Handling
@app.errorhandler(404)
def not_found_api(error):
    return jsonify({
        'error': 'Resource not found',
        'status_code': 404
    }), 404

@app.errorhandler(400)
def bad_request(error):
    return jsonify({
        'error': 'Bad request',
        'message': str(error.description)
    }), 400

@app.errorhandler(401)
def unauthorized(error):
    return jsonify({
        'error': 'Authentication required',
        'status_code': 401
    }), 401

@app.errorhandler(403)
def forbidden(error):
    return jsonify({
        'error': 'Access forbidden',
        'status_code': 403
    }), 403

@app.errorhandler(405)
def method_not_allowed(error):
    return jsonify({
        'error': 'Method not allowed',
        'allowed_methods': error.valid_methods
    }), 405

3. Custom Error Classes
class ValidationError(Exception):
    """Custom validation error"""
    def __init__(self, message, status_code=400):
        super().__init__(message)
        self.message = message
        self.status_code = status_code

@app.errorhandler(ValidationError)
def handle_validation_error(error):
    response = jsonify({
        'error': 'Validation Error',
        'message': error.message
    })
    response.status_code = error.status_code
    return response

# Using custom error
@app.route('/api/user', methods=['POST'])
def create_user():
    data = request.get_json()
    if not data or 'email' not in data:
        raise ValidationError('Email is required')
    if '@' not in data['email']:
        raise ValidationError('Invalid email format')
    # Process user creation...
    return jsonify({'status': 'success'})

4. Generic Error Handler for All Exceptions
@app.errorhandler(Exception)
def handle_exception(e):
    # Log the error
    app.logger.error(f'Unhandled exception: {str(e)}')
    
    # Return appropriate response
    if isinstance(e, HTTPException):
        response = {
            'error': e.name,
            'description': e.description,
            'code': e.code
        }
        return jsonify(response), e.code
    else:
        # Non-HTTP exceptions
        response = {
            'error': 'Internal Server Error',
            'message': str(e) if app.debug else 'An unexpected error occurred'
        }
        return jsonify(response), 500

5. Aborting with Custom Messages
from flask import abort

@app.route('/resource/<int:resource_id>')
def get_resource(resource_id):
    resource = find_resource(resource_id)
    if resource is None:
        abort(404, description=f"Resource {resource_id} not found")
    return jsonify(resource)

@app.route('/admin-only')
def admin_only():
    if not current_user.is_admin:
        abort(403, description="Admin access required")
    return "Admin content"

6. Blueprint-specific Error Handlers
from flask import Blueprint

api_bp = Blueprint('api', __name__)

@api_bp.errorhandler(404)
def api_not_found(error):
    return jsonify({'error': 'API endpoint not found'}), 404

@api_bp.errorhandler(429)
def rate_limit_exceeded(error):
    return jsonify({
        'error': 'Rate limit exceeded',
        'retry_after': error.description
    }), 429

7. Centralized Error Handling with Error Classes
class APIError(Exception):
    def __init__(self, message, status_code=400, payload=None):
        super().__init__()
        self.message = message
        self.status_code = status_code
        self.payload = payload
    
    def to_dict(self):
        rv = dict(self.payload or {})
        rv['error'] = self.message
        rv['status_code'] = self.status_code
        return rv

@app.errorhandler(APIError)
def handle_api_error(error):
    response = jsonify(error.to_dict())
    response.status_code = error.status_code
    return response

# Usage
@app.route('/api/transfer')
def transfer_money():
    amount = request.args.get('amount', type=float)
    if amount <= 0:
        raise APIError('Amount must be positive', 400)
    if amount > balance:
        raise APIError('Insufficient funds', 402, {'balance': balance})
    # Process transfer...

8. Logging Errors
import logging
from logging.handlers import RotatingFileHandler

# Configure logging
handler = RotatingFileHandler('error.log', maxBytes=10000, backupCount=3)
handler.setLevel(logging.ERROR)
app.logger.addHandler(handler)

@app.errorhandler(500)
def handle_500(error):
    app.logger.error(f'Server Error: {error}', exc_info=True)
    return render_template('500.html'), 500

9. Custom Error Templates
<!-- templates/404.html -->
{% extends "base.html" %}
{% block content %}
<div class="error-container">
    <h1>404 - Page Not Found</h1>
    <p>The page you're looking for doesn't exist.</p>
    <a href="{{ url_for('index') }}">Return to Home</a>
</div>
{% endblock %}

<!-- templates/500.html -->
{% extends "base.html" %}
{% block content %}
<div class="error-container">
    <h1>500 - Internal Server Error</h1>
    <p>Something went wrong on our end. Please try again later.</p>
    <a href="{{ url_for('index') }}">Return to Home</a>
</div>
{% endblock %}

10. Error Handling Best Practices
• Always log errors for debugging
• Don't expose sensitive information in error messages
• Use appropriate HTTP status codes
• Provide helpful error messages
• Handle validation errors gracefully
• Implement rate limiting error responses
• Use consistent error response format
• Test error scenarios
• Handle database rollbacks on errors

Complete Example with Multiple Handlers:
class ErrorHandler:
    @staticmethod
    def init_app(app):
        @app.errorhandler(404)
        def handle_404(e):
            if request.path.startswith('/api/'):
                return jsonify({'error': 'Endpoint not found'}), 404
            return render_template('errors/404.html'), 404
        
        @app.errorhandler(403)
        def handle_403(e):
            if request.path.startswith('/api/'):
                return jsonify({'error': 'Forbidden'}), 403
            return render_template('errors/403.html'), 403
        
        @app.errorhandler(ValidationError)
        def handle_validation(e):
            return jsonify(e.to_dict()), 400
        
        @app.errorhandler(Exception)
        def handle_general(e):
            app.logger.error(f'Unexpected error: {str(e)}', exc_info=True)
            if request.path.startswith('/api/'):
                return jsonify({'error': 'Internal server error'}), 500
            return render_template('errors/500.html'), 500

ErrorHandler.init_app(app)""")
pdf.ln(5)

# Question 10
pdf.question('10', 'How do you structure a Flask app using Blueprints?')
pdf.answer("""Blueprints in Flask are used to organize applications into modular components, making them more maintainable and scalable.

Basic Blueprint Structure:

Project Structure with Blueprints:
my_flask_app/
├── run.py
├── config.py
├── requirements.txt
├── app/
│   ├── __init__.py
│   ├── models.py
│   ├── extensions.py
│   ├── main/
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── auth/
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── admin/
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── templates/
│   │   ├── main/
│   │   ├── auth/
│   │   └── admin/
│   └── static/
│       ├── css/
│       └── js/
└── tests/

1. Creating Blueprints

# app/main/__init__.py
from flask import Blueprint

main_bp = Blueprint('main', __name__)

# Import routes at the bottom to avoid circular imports
from . import routes

# app/main/routes.py
from flask import render_template
from . import main_bp

@main_bp.route('/')
def index():
    return render_template('main/index.html')

@main_bp.route('/about')
def about():
    return render_template('main/about.html')

@main_bp.route('/contact')
def contact():
    return render_template('main/contact.html')

# app/auth/__init__.py
from flask import Blueprint

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

from . import routes

# app/auth/routes.py
from flask import render_template, redirect, url_for, flash, request
from . import auth_bp

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        # Process login
        return redirect(url_for('main.index'))
    return render_template('auth/login.html')

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        # Process registration
        return redirect(url_for('auth.login'))
    return render_template('auth/register.html')

@auth_bp.route('/logout')
def logout():
    # Process logout
    return redirect(url_for('main.index'))

# app/api/__init__.py
from flask import Blueprint

api_bp = Blueprint('api', __name__, url_prefix='/api/v1')

from . import routes

# app/api/routes.py
from flask import jsonify, request
from . import api_bp

@api_bp.route('/users')
def get_users():
    users = [{'id': 1, 'name': 'John'}, {'id': 2, 'name': 'Jane'}]
    return jsonify(users)

@api_bp.route('/users/<int:user_id>')
def get_user(user_id):
    user = {'id': user_id, 'name': f'User {user_id}'}
    return jsonify(user)

@api_bp.route('/users', methods=['POST'])
def create_user():
    data = request.get_json()
    # Process creation
    return jsonify({'status': 'created', 'user': data}), 201

# app/admin/__init__.py
from flask import Blueprint

admin_bp = Blueprint('admin', __name__, url_prefix='/admin')

from . import routes

# app/admin/routes.py
from flask import render_template, abort
from functools import wraps
from . import admin_bp

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Check if user is admin
        if not current_user.is_admin:
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

@admin_bp.route('/dashboard')
@admin_required
def dashboard():
    return render_template('admin/dashboard.html')

@admin_bp.route('/users')
@admin_required
def manage_users():
    return render_template('admin/users.html')

2. Application Factory Pattern with Blueprints

# app/__init__.py
from flask import Flask
from config import Config
from .extensions import init_extensions

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    # Initialize extensions
    init_extensions(app)
    
    # Register blueprints
    register_blueprints(app)
    
    # Register error handlers
    register_error_handlers(app)
    
    # Register context processors
    register_context_processors(app)
    
    return app

def register_blueprints(app):
    from .main import main_bp
    from .auth import auth_bp
    from .api import api_bp
    from .admin import admin_bp
    
    app.register_blueprint(main_bp)
    app.register_blueprint(auth_bp)
    app.register_blueprint(api_bp)
    app.register_blueprint(admin_bp)

def register_error_handlers(app):
    @app.errorhandler(404)
    def not_found_error(error):
        return render_template('errors/404.html'), 404
    
    @app.errorhandler(500)
    def internal_error(error):
        return render_template('errors/500.html'), 500

def register_context_processors(app):
    @app.context_processor
    def utility_processor():
        def format_date(date):
            return date.strftime('%Y-%m-%d')
        return dict(format_date=format_date)

# app/extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager
from flask_mail import Mail

db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()
mail = Mail()

def init_extensions(app):
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    mail.init_app(app)
    
    # Configure login
    login_manager.login_view = 'auth.login'
    login_manager.login_message = 'Please log in to access this page.'

3. Template Organization with Blueprints

<!-- app/templates/main/index.html -->
{% extends "base.html" %}
{% block title %}Home{% endblock %}
{% block content %}
<h1>Welcome to the Home Page</h1>
{% endblock %}

<!-- app/templates/auth/login.html -->
{% extends "base.html" %}
{% block title %}Login{% endblock %}
{% block content %}
<h1>Login</h1>
<form method="POST">
    {{ form.hidden_tag() }}
    <input type="text" name="username" placeholder="Username">
    <input type="password" name="password" placeholder="Password">
    <button type="submit">Login</button>
</form>
{% endblock %}

4. URL Generation with Blueprints

# In templates
<a href="{{ url_for('main.index') }}">Home</a>
<a href="{{ url_for('auth.login') }}">Login</a>
<a href="{{ url_for('api.get_users') }}">API Users</a>
<a href="{{ url_for('admin.dashboard') }}">Admin</a>

# In Python code
from flask import url_for

# Generate URLs
home_url = url_for('main.index')
login_url = url_for('auth.login')
user_api_url = url_for('api.get_user', user_id=123)

5. Advanced Blueprint Features

# Blueprint with subdomain
api_v2_bp = Blueprint('api_v2', __name__, 
                      url_prefix='/api/v2',
                      subdomain='api')

# Blueprint with static folder
static_bp = Blueprint('static_pages', __name__,
                     static_folder='static',
                     template_folder='templates')

# Blueprint with custom error handlers
@api_bp.errorhandler(404)
def api_not_found(error):
    return jsonify({'error': 'API endpoint not found'}), 404

# Blueprint before/after request
@api_bp.before_request
def before_api_request():
    # Check API key, rate limiting, etc.
    pass

@api_bp.after_request
def after_api_request(response):
    # Add headers, logging, etc.
    response.headers.add('X-API-Version', '1.0')
    return response

6. Configuration per Blueprint

# In blueprint
api_bp = Blueprint('api', __name__)

@api_bp.record
def record_params(setup_state):
    app = setup_state.app
    api_key = app.config.get('API_KEY')
    # Use configuration

7. Complete Application Factory Example

# run.py
from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-key-123'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///app.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    API_KEY = os.environ.get('API_KEY')

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'

8. Benefits of Using Blueprints
• Modularity: Separate concerns into logical modules
• Reusability: Blueprints can be reused across projects
• Maintainability: Easier to maintain and update
• Scalability: Easy to add new features
• Team collaboration: Different teams can work on different blueprints
• Testing: Easier to test individual components
• URL organization: Clean URL structure with prefixes
• Template organization: Organized template structure""")
